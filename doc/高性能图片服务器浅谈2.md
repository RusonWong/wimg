#高性能图片服务器zimg#
####Architecture Design of Image Server####
[@招牌疯子](http://weibo.com/buaazp)

##综述##
最近几年，随着社交网络的崛起和智能手机的普及，互联网上图片的产生和分享变得更加容易。在2012年，Facebook平均每天增加新图片3亿张，每个月增加的图片数据达7PB。同一年，用户每秒钟向老牌图片分享网站Flickr上传图片2777张，其中绝大部分来自智能手机，目前Flickr最热门相机前三名分别是iPhone 4S，iPhone 5和iPhone 4。而作为后起之秀的Instagram，仅用了不到2年的时间就拥有了50亿张照片。再看国内的情况，带有图片的微博占到了新浪微博总数的40%以上，而这一数据在微信中更是达到了惊人的90%，在淘宝网的整体流量中，图片的访问流量要占到90%以上。

虽然很难获得精确的统计数据，但图片在整个互联网流量中所占比例的提高已是不争的事实，知名天使投资人蔡文胜就在采访中表示这一比例应该在一半以上[1]。由此可见，对图片的处理能力也相应地变成企业和开发者的一项基本技能。需要处理海量图片的典型应用有：

1. 图片类应用，如Flickr，Instagram，美图秀秀等。
2. 社交网络类应用，如Facebook，新浪微博，微信等。
3. 电商类应用，如Amazon，淘宝，Guang.com等。
4. 图片类云存储服务，如百度云，七牛云存储等。

除此之外几乎所有的网站都需要考虑自己图片处理的解决方案，以免在流量变大之后显得手足无措。

本文将从作者自己设计完成的图片服务程序[zimg](http://zimg.buaa.us/)的设计思路出发，探讨高性能图片服务器的特点、难点和应对办法。

##主要问题##

要想处理好图片，需要面对的三个主要问题是：大流量，高并发，海量存储。下面将逐一进行讨论。

###大流量###

除了那些拥有自己数据中心的大型企业，中小型企业都需要考虑流量问题，图片相对于文本来说流量增加了一个数量级，省下的每一个字节都是可观的成本。我曾经在一篇博客[2]里看到，为了节约网站流量，一位程序员选择了PHP的Imagick库来进行压缩，在转换编码、压缩和去除EXIF信息之后，图片大小被大大降低，短短几行代码就做到了每个月为公司节省2万元人民币的效果，可见凡是涉及到图片的互联网应用，都应该统筹规划，降低流量节约开支。

###高并发###

高并发的问题在用户量较低时几乎不会出现，但是一旦用户攀升，或者遇到热点事件，比如淘宝的双十一，或者网站被人上传了一张爆炸性的新闻图片，短时间内将会涌入大量的浏览请求，如果架构设计得不好，又没有紧急应对方案，很可能导致大量的等待、更多的页面刷新和更多请求的死循环。总的来说，就是要把图片服务的性能做得足够好。

###海量存储###

在介绍Facebook图片存储的文章[3]里提到，当时Facebook用户就上传了图片15亿张，总容量超过了1.5PB，而现在的数量已经远远超过当年，这样的数量级是一般企业无法承受的。虽然我们很难做出一个可以跟Facebook比肩的应用，但是从架构设计的角度来说，良好的拓展方案还是要有的。我们需要提前设计出最合适的海量数据存储方案和操作方便的拓容方案，以应对将来不断增长的业务需求。

以上三个问题，其实也是相互制约和钳制的，比如要想降低流量，就需要做大量的运算，导致请求处理时间延长，系统单位时间内的处理能力下降；再比如为了存储更多的图片，必然要在查找上消耗资源，同样也会降低处理能力。所以，图片服务虽然看起来业务简单，实际做起来也不是一件小事。

##设计方案##

zimg是作者针对图片处理服务器而设计开发的开源程序，它拥有很高的性能，也满足了应用在图片方面最基本的处理需求，下面将从架构设计、代码逻辑和性能测试等方面进行介绍。

###总体思路###

想要在展现图片这件事情上有最好的表现，首先需要从整体业务中将图片服务部分分离出来。使用单独的域名和建立独立的图片服务器有很多好处，比如：

1. CDN分流。如果你有注意的话，热门网站的图片地址都有特殊的域名，比如微博的是ww1.sinaimg.cn，人人的是fmn.xnpic.com等等，域名不同可以在CDN解析的层面就做到非常明显的优化效果。
2. 浏览器并发连接数限制。一般来说，浏览器加载HTML资源时会建立很多的连接，并行地下载资源。不同的浏览器对同一主机的并发连接数限制是不同的，比如IE8是10个，Firefox是30个。如果把图片服务器独立出来，就不会占用掉对主站连接数的名额，一定程度上提升了网站的性能。
3. 浏览器缓存。现在的浏览器都具有缓存功能，但是由于cookie的存在，大部分浏览器不会缓存带有cookie的请求，导致的结果是大量的图片请求无法命中，只能重新下载。独立域名的图片服务器，可以很大程度上缓解此问题。

图片服务器被独立出来之后，会面临两个选择，主流的方案是前端采用Nginx，中间是PHP或者自己开发的模块，后端是物理存储；比较特别一些的，比如Facebook，他们把图片的请求处理和存储合并成一体，叫做Haystack，这样做的好处是，Haystack只会处理与图片相关的请求，剥离了普通HTTP服务器繁杂的功能，更加轻量高效，同时也使部署和运维难度降低。

**zimg采用的是与Facebook相似的策略，将图片处理的大权收归自己所有，绝大部分事情都由自己处理，除非特别必要，最小程度地引入第三方模块。**

###架构设计###

为了极致的性能表现，zimg全部采用C语言开发，总体上分为三个层次，前端HTTP处理层，中间图片处理层和后端的存储层。下图为zimg架构设计图：

![总体架构](http://single1024.qiniudn.com/wp-content/uploads/2013/08/zimg_arch.png)

HTTP处理层引入基于libevent的[libevhtp](https://github.com/ellzey/libevhtp)库，libevhtp是一款专门处理基本HTTP请求的库，它太适合zimg的业务场景了，在性能和功能之间找到了很好的平衡点。图片处理层采用Imagemagick库，Imagemagick是现在公认功能最强，性能最好的图片处理函数库。存储层采用memcached缓存加直接读写硬盘的方案，更加深入的优化将在后续进行，比如引入TFS[4]等。为了避免数据库带来的性能瓶颈，zimg不引入结构化数据库，图片的查找全部采用哈希来解决。

**事实上图片服务器的设计，是一个在I/O与CPU运算之间的博弈过程**，最好的策略当然是继续拆：CPU敏感的HTTP和图片处理层部署于运算能力更强的机器上，内存敏感的cache层部署于内存更大的机器上，I/O敏感的物理存储层则放在配备SSD的机器上，但并不是所有人都能负担得起这么奢侈的配置。zimg折中成本和业务需求，目前只需要部署在一台服务器上。由于不同服务器硬件不同，I/O和CPU运算速度差异很大，很难一棒子定死。zimg所选择的思路是，尽量减少I/O，将压力放在CPU上，事实证明这样的思路基本没错，在硬盘性能很差的机器上效果更加明显；即使以后SSD全面普及，CPU的运算能力也会相应提升，总体来说zimg的方案也不会太失衡。

###代码层面###

虽然zimg在二进制实体上没有分模块，是因为现阶段面向中小型的服务，单机部署即可，但是代码上是分离的，下面介绍主要部分的功能和实现，更详细的内容可以从GitHub上拉下来研究。欢迎大家fork和contribute。

***main.c***是程序的入口，主要功能是处理启动参数，部分参数功能如下：

	-p [port] 监听端口号，默认4869
	-t [thread_num] 线程数，默认4，请调整为具体服务器的CPU核心数
	-k [max_keepalive_num] 最高保持连接数，默认1，不启用长连接，0为启用
	-l 启用log，会带来很大的性能损失，自行斟酌是否开启
	-M [memcached_ip] 启用缓存的连接IP
	-m [memcached_port] 启用缓存的连接端口
	-b [backlog_num] 每个线程的最大连接数，默认1024，酌情设置

***zhttpd.c***是解析HTTP请求的部分，分为GET和POST两大部分，GET请求会根据请求的URL参数去寻找图片并转给图片处理层处理，最后将结果返回给用户；POST接收上传请求然后将图片存入计算好的路径中。
为了实现zimg的总体设计愿景，zhttpd承担了很大部分的工作，也有一些关键点，下面捡重点的说一下：

在zimg中图片的唯一Key值就是该图片的MD5，这样既可以隐藏路径，又能减少前端（指zimg前面的部分，可能是你的应用服务器）和zimg本身的存储压力，是避免引入结构化存储部分的关键，所以所有GET请求都是基于MD5拼接而成的。

大家设想一下，假如你的网站某个地方需要展示一张图片，这个图片原图的大小是1000\*1000，但是你想要展示的地方只有300\*300，你会怎么做呢？一般还是依靠CSS来进行控制，但是这样的话就会造成很多流量的浪费。为此，zimg提供了图片裁剪功能，你所需要做的就是在图片URL后面加上w=300&h=300（width和height）即可。

另一个情景是图片灰白化，比如某天遇到重大自然灾害，想要网站所有图片变成灰白的，那么只需在图片URL后面再加上g=1（gray）即可。

当然，依托于Imagemagick所提供的完善的图片处理函数，zimg将在后续版本中逐步增加功能，比如加水印等。

在图片上传部分，其实能玩的花样很少，但是编写代码所消耗的时间最多。现在我们再假设一种情景，如果我们的图片服务器前端采用Nginx，上传功能用PHP实现，需要写的代码很少，但是性能如何呢，答案是很差。首先PHP接收到Nginx传过来的请求后，会根据HTTP协议（RFC1867）分离出其中的二进制文件，存储在一个临时目录里，等我们在PHP代码里使用$_FILES["upfile"][tmp_name]获取到文件后计算MD5再存储到指定目录，在这个过程中**有一次读文件一次写文件是多余的**，其实最好的情况是我们拿到HTTP请求中的二进制文件（最好在内存里），直接计算MD5然后存储。

于是我参考PHP的源代码，自己实现了POST文件的解析，让HTTP层直接和存储层连在了一起，提高了上传图片的性能。关于RFC1867的内容和PHP是如何处理的，感兴趣的读者可以去搜索了解下，这里推荐[@Laruence](http://weibo.com/laruence)的文章[《PHP文件上传源码分析(RFC1867) 》](http://www.laruence.com/2009/09/26/1103.html)。

除了POST请求这个例子，zimg代码中有多处都体现了这种“减少磁盘I/O，尽量在内存中读写”和“避免内存复制”的思想，一点点的积累，最终将会带来优秀的表现。

***zimg.c***是调用Imagemagick处理图片的部分，这里先解释一下在zimg中图片存储路径的规划方案。
上文曾经提到，现阶段zimg服务于存储量中等的单机图片服务器，所以存储路径采用2级子目录的方案。由于Linux同目录下的子目录数最好不要超过2000个，再加上MD5的值本身就是32位十六进制数，zimg就采取了一种非常取巧的方式：根据MD5的前六位进行哈希，1-3位转换为十六进制数后除以4，范围正好落在1024以内，以这个数作为第一级子目录；4-6位同样处理，作为第二级子目录；二级子目录下是以MD5命名的文件夹，每个MD5文件夹内存储图片的原图和其他根据需要存储的版本，假设一个图片平均占用空间200KB，一台zimg服务器支持的总容量就可以计算出来了：

	1024 * 1024 * 1024 * 200KB = 200TB

这样的数量应该已经算很大了，在200TB的范围内可以采用加硬盘的方式来拓容，当然如果有更大的需求，请期待zimg后续版本的分布式集群存储支持。

除了路径规划，zimg另一大功能就是压缩图片。从用户角度来说，zimg返回来的图片只要看起来跟原图差不多就行了，如果确实需要原图，也可以通过将所有参数置空的方式来获得。基于这样的条件，zimg.c对于所有转换的图片都进行了压缩，压缩之后肉眼几乎无法分辨，但是体积将减少67.05%。具体的处理方式为：

	图片裁剪时使用LanczosFilter滤镜；
	以75%的压缩率进行压缩；
	去除图片的Exif信息；
	转换为JPEG格式。

经过这样的处理之后可以很大程度的减少流量，实现设计目标。

***zcache.c***是引入memcached缓存的部分，引入缓存是很重要的，尤其是图片量级上升之后。在zimg中缓存被作为一个很重要的功能，几乎所有zimg.c中的查找部分都会先去检查缓存是否存在。比如：

我想要a（代表某MD5）图片裁剪为100*100之后再灰白化的版本，那么过程是先去找a&w=100&h=100&g=1的缓存是否存在，不存在的话去找这个文件是否存在（这个请求所对应的文件名为 a/100\*100pg），还不存在就去找这个分辨率的彩色图缓存是否存在，若依然不存在就去找彩色图文件是否存在（对应的文件名为 a/100\*100p），若还是没有，那就去查询原图的缓，原图缓存依然未命中的话，只能打开原图文件了，然后开始裁剪，灰白化，然后返回给用户并存入缓存中。

可以看出，上面过程中如果某个环节命中缓存，就会相应地减少I/O或图片处理的运算次数。众所周知内存和硬盘的读写速度差距是巨大的，那么这样的设计对于热点图片抗压将会十分重要。

除了上述核心代码以外就是一些支持性的代码了，比如log部分，md5计算部分，util部分等。

##性能测试##

为了横向对比zimg的性能，我用PHP写了一个功能一模一样的后端，仅用时一下午，可见采用PHP方案的话开发成本将会大大降低。不过，我喜欢性能测试结果出来之后的那份成就感，这样的付出我觉得是值得的。

###测试方案###

采用Apache自带的测试程序ab对指定请求进行测试，在并发数100的情况下进行10w个请求的测试，结果依据该并发下每秒处理请求数来定性，对比的方案是未启用缓存的zimg，启用缓存的zimg和Nginx+PHP，其中zimg端口为4868，Nginx端口为80。限于篇幅，详细的测试环境和软件版本等信息可以在zimg主页上benchmark结果中查看，此处仅列出测试结果。

	注：以下测试数据单位皆为rps（request per second）。

###测试结果###

| 测试项目 |zimg| zimg+memcached |Nginx+PHP|
| :------:| :----: | :----: | :----:|
| 静态图片 | 2857.80 | 4995.95| 426.56 |
| 动态裁剪图片| 2799.34 | 4658.35 |58.61|

总的来说测试结果符合预期，纯C写成并且专门为图片而做了大量优化的zimg表现远远优于采用PHP的方案，性能有6-79倍的提升。

###高压测试###

在测试过程中由于php-fpm的性能瓶颈，导致并发压力根本压不上去，为了充分展现zimg面对超高并发的抗压能力，我又做了另一项对比测试，即单纯的echo测试。测试方法是在逐渐升高的并发压力下完成20w个echo请求，记录每种并发压力下的处理能力。硬件环境不变，这次所要对比的是业界以性能著称的Nginx，Nginx和zimg都是接收echo请求后返回简单的“It works！”页面，不做任何复杂的业务。

在测试过程中，Nginx从并发1000开始已经出现了部分失败，在并发9000以后就无法完成20w个请求，通过不断降低请求数才勉强完成了测试。而强大的zimg毫无压力地完成了20000并发以内的所有测试，没有一个失败返回。下面是结果对比图表：

![测试结果](http://single1024.qiniudn.com/wp-content/uploads/2013/08/zimg_vs_nginx.png)

由于去掉了不需要的复杂功能，zimg在HTTP处理层面要远比Nginx轻量，同时测试数据也说明了它的高并发抗压能力。能有这样的成绩则完全要归功于libevhtp项目，它比libevent自带的HTTP库要优秀得多。在我设计zimg的早期版本时，选用了libevent自带的evhttp库，然后采用线程池的方式来实现多线程处理，结果发现在高压力之下问题频出，最后无奈放弃。该版本封存在GitHub上的zimg_workqueue分支中，也算是一个纪念吧。

##最后##

图片服务器的设计多种多样，许多企业都针对自身业务设计了独特的方案，下面简单对比一下业界常用方案的优缺点：

1. Nginx/Apache + PHP + 存储集群：该方案设计部署简单，可以用最短的时间满足基本的需求；缺点是处理能力有限，很容易达到瓶颈，无法很好地支撑大型网站。
2. Client + TFS：淘宝依靠自身强大的技术实力开发了针对小图片存储的TFS，将部分元数据巧妙地隐藏到了文件名中，然后通过系统中的NameServer进行解析定位（这个思路与zimg中的哈希定位有些神似），可用性和速度都是业界一流；但缺点是系统复杂，维护困难，对技术人员要求较高。
3. Haystack：Facebook私有方案，支撑着世界上最大的图片库，并发性能好，架构设计与zimg很相似，大家可以将zimg看作是开源版、轻量级的Haystack；缺点是未开源，暂时无法使用。
4. 第三方云存储：此方案对于创业公司来说最为方便，许多技术上的细节问题无需考虑，只需要依据接口文档使用即可；但缺点也很明显，费用较高，数据无法自己处理，不够灵活。

而zimg的1.0版本，设计面向图片量在TB级别的中小型服务，虽然有些亮点，也有很多不足，比如：

- 物理存储暂时不支持分布式集群；
- 没有备份功能；
- 未处理安全和防盗链相关问题。

以上这些短板，也正是zimg在后续版本中将要提高的地方。zimg才发布不久，以后还有很长的路要走，希望有兴趣的朋友加入进来，一起完善功能，提高性能，让它可以发展壮大。

那么，就用这样一句经典而充满力量的话作为结尾吧。

>We stand on the shoulders of giants. 





[1]:http://tech.sina.com.cn/i/csj/2013-05-28/08548385597.shtml 美图手机看互联网图片化
[2]:http://hi.baidu.com/bjmayor/item/bdb066ddd08263f8cb0c39cd 此本的转载
[3]:http://www.biaodianfu.com/facebook-efficient-storage-of-billions-of-photos.html Facebook图片存储架构学习
[4]:https://github.com/alibaba/tfs TFS
